abort "jaxb2ruby must be ran using JRuby" unless RUBY_PLATFORM == "java"

require "active_support/core_ext/string"
require "active_support/inflector"
require "erb"
require "find"
require "fileutils"
require "java"

# Not a JRuby way to do this..?
TYPEMAP = {
  "boolean" => :boolean,
  "java.lang.Boolean" => :boolean,
  "java.lang.String" => "String",
  "java.math.BigDecimal" => "Integer",
  "java.math.BigInteger" => "Integer",
  "javax.xml.datatype.Duration" => "String",
  "javax.xml.datatype.XMLGregorianCalendar" => "DateTime",
  # others...
}

# Define some things here and use @class as ERB arg instead
Template = Class.new

# Maybe...
# class Namespace < String
#   def prefix
#     # something
#   end
# end

class Node
  attr :type
  attr :name
  attr :namespace
  attr :accessor

  def initialize(name, options = {})
    @name = name
    @accessor = name.underscore
    @namespace = options[:namespace]
    @type = options[:type]
    @required = !!options[:required]

    if @type == :boolean && @accessor.start_with?("is_")
      @accessor["is_"] = ""
      @accessor << "?"
    end
  end

  def required?
    @required
  end
end

class Attribute < Node; end

class Element < Node
  attr :children
  attr :attributes

  def initialize(name, options = {})
    super

    @array = !!options[:array]
    @text = !!options[:text]
    @children = options[:children] || []
    @attributes = options[:attributes] || []

    # Uhhhh, I think this might need some revisiting, esp. with xsd:enumeration
    if @type.is_a?(Array)
      @accessor = @accessor.pluralize

      if @type.one?
        @array = true
        @type = @type.shift
      else
        @hash = true
      end
    end
  end

  def text?
    @text
  end

  def hash?
    @hash
  end

  def array?
    @array
  end
end

class RubyClass
  attr :class
  attr :name
  attr :module
  attr :element

  def initialize(klass, element)
    @class = klass
    @name  = klass.demodulize
    @module = klass.deconstantize # >= 3.2
    @element = element

    @module.extend Enumerable
    def @module.each(&block)
      split("::").each(&block)
    end

    def @module.to_a
      entries
    end
  end

  def filename
    "#@name.rb"
  end

  def directory
    File.dirname(path)
  end
  
  def path
    @path ||= @module.to_a.push(filename).map { |mod| mod.underscore }.join("/")
  end

  # Bit of a last second hack here :(
  def requires        
    @requires ||= begin
      req = []
      (element.children + element.attributes).each do |node| 
        # Only select types that look like a module
        next unless node.type.is_a?(String) and node.type.index("::")
        req << node.type.split("::").map { |mod| mod.underscore }.join("/") 
      end
      req.sort
    end
  end
end

# Load from YAML file
def mapns(ns)
  mapping = {
    "http://ddex.net/xml/ern/341" => "DDEX::ERN::V341",
    "http://ddex.net/xml/20120404/ddexC" => "DDEX::V20120404::DDEXC",
    "http://ddex.net/xml/20120404/ddex" => "DDEX::V20120404::DDEX"
  }
  mapping[ns] || ns
end

def find_classes(root)
  root = File.expand_path(root) << "/"
  classes = []

  Find.find(root) do |path|
    if File.file?(path) && File.extname(path) == ".class" && !File.basename(path).start_with?("package-info.")
      path[root] = ""   # Want com/example/Class not root/com/example/Class
      classes << path
    end
  end

  classes.map { |path| java_name_from_path(path) }
end

def ruby_name_from_java(pkg)
  pkg.to_s.split(".")[1..-1].map { |s|
    s.sub(/\A_/, "V").camelize
  }.join "::"
end

def java_name_from_path(path)
  klass = path.split(%r{/}).join(".")
  klass[%r{\.class\Z}] = ""
  klass
end

def extract_namespace(klass)
  pkg = klass.package
  ns = pkg.get_annotation(javax.xml.bind.annotation.XmlSchema.java_class)
  ns.namespace if ns
end

def translate_type(klass)
  return TYPEMAP[klass.name] if TYPEMAP.include?(klass.name)
  return "String" if klass.enum?

  if modname = mapns(extract_namespace(klass))
    type = klass.name
    type.sub!("#{klass.get_package.name}.", "#{modname}::")
  else
    ruby_name_from_java(klass.name)
  end
end

def resolve_type(field)
  return :ID if field.annotation_present?(javax.xml.bind.annotation.XmlID.java_class)
  return :IDREF if field.annotation_present?(javax.xml.bind.annotation.XmlIDREF.java_class)

  type = field.generic_type
  if type.java_kind_of?(java.lang.reflect.ParameterizedType) #||
    #type.java_kind_of?(Java::java.lang.reflect.GenericArrayType) ||
    #type.java_kind_of?(Java::java.lang.reflect.TypeVariable)
    type.actual_type_arguments.map { |t| translate_type(t) }
  else
    # should probably capture enum values
    translate_type(type)
  end
end

def extract_class(klass)
  type = translate_type(klass)
  element = extract_element(klass)
  RubyClass.new(type, element)
end

def extract_element(klass)
  options = {
    :namespace  => extract_namespace(klass),
    :attributes => [],
    :children   => []
  }

  klass.declared_fields.each do |field|
    annot = field.get_annotation(javax.xml.bind.annotation.XmlElement.java_class)
    if annot
      options[:children] << Element.new(annot.name, :type => resolve_type(field), :required => annot.required?)
    elsif field.annotation_present?(javax.xml.bind.annotation.XmlValue.java_class)
      options[:text] = true
    elsif annot = field.get_annotation(javax.xml.bind.annotation.XmlAttribute.java_class)
      options[:attributes] << Attribute.new(annot.name, :type => resolve_type(field), :required => annot.required?)
    else
      warn "Cannot extract element/attribute from: #{klass.name}.#{field.name})"
    end
  end

  # Get the element's name
  annot = klass.get_annotation(javax.xml.bind.annotation.XmlType.java_class)
  name  = annot.name
  if name.empty?
    annot = klass.get_annotation(javax.xml.bind.annotation.XmlRootElement.java_class)
    name  = annot.name
  end

  # Should grab annot.prop_order
  # annot.prop_order are java props here we have element names
  # element.elements.sort_by! { |e| annot.prop_order.index }
  Element.new(name, options)
end

def valid_class?(klass)
  return false if klass.java_class.enum?   # Skip Enum for now, maybe for ever!
  return false if klass.java_class.annotation_present?(javax.xml.bind.annotation.XmlRegistry.java_class)
  return false unless klass.java_class.annotation_present?(javax.xml.bind.annotation.XmlType.java_class) or
                      klass.java_class.annotation_present?(javax.xml.bind.annotation.XmlRootElement.java_class)
  true
end

def extract_classes(java_classes)
  ruby_classes = []
  java_classes.each do |name|
    klass = Java.send(name)
    next unless valid_class?(klass)
    ruby_classes << extract_class(klass.new.get_class)
  end
  ruby_classes
end

def save_classes(classes)
  # Just do this once!  
  ERB.new(File.read("roxml.erb"), nil, "<>%-").def_method(Template, "render(klass)")
  t = Template.new
  outdir = "out/"
  classes.each do |klass|
    puts "Generating: #{klass.path}"
    FileUtils.mkdir_p(outdir + klass.directory)
    File.open(outdir + klass.path, "w") { |io| io.puts t.render(klass) }
  end
end

abort "usage: #{File.basename($0)} [OPTIONS] classes" if ARGV.empty?
$CLASSPATH << File.join(Dir.pwd, ARGV[0])

classes = find_classes(ARGV[0])
abort "No classes found at: #{ARGV[0]}" if classes.empty?
save_classes(extract_classes(classes))
